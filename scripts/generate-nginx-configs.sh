#!/bin/sh

# Generate nginx configurations from projects.conf
# Generates nginx/conf.d/*.conf for HTTP/HTTPS and nginx/stream.d/*.conf for MySQL proxying

set -e

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
CONFIG_FILE="$PROJECT_ROOT/projects.conf"
NGINX_CONF_D="$PROJECT_ROOT/nginx/conf.d"
NGINX_STREAM_D="$PROJECT_ROOT/nginx/stream.d"
CERTS_PATH="$PROJECT_ROOT/nginx/certs"

# Check if yq is installed
if ! command -v yq >/dev/null 2>&1; then
  echo "Error: yq is not installed. Install it with: brew install yq"
  exit 1
fi

# Check if projects.conf exists
if [ ! -f "$CONFIG_FILE" ]; then
  echo "Error: projects.conf not found. Create it from projects.conf.example first."
  exit 1
fi

# Create directories if they don't exist
mkdir -p "$NGINX_CONF_D"
mkdir -p "$NGINX_STREAM_D"
mkdir -p "$CERTS_PATH"

# Load .env variables
if [ -f "$PROJECT_ROOT/.env" ]; then
  export $(grep -v '^#' "$PROJECT_ROOT/.env" | xargs)
fi

# Get all project names
projects=$(yq eval 'keys | .[]' "$CONFIG_FILE" 2>/dev/null || echo "")

if [ -z "$projects" ]; then
  echo "No projects found in projects.conf"
  exit 0
fi

# Remove old generated configs (but keep mailpit.conf and other non-generated files)
# We'll mark generated files with a comment
for conf_file in "$NGINX_CONF_D"/*.conf; do
  if [ -f "$conf_file" ]; then
    # Check if it's a generated file (contains "# Generated by generate-nginx-configs.sh")
    if grep -q "# Generated by generate-nginx-configs.sh" "$conf_file" 2>/dev/null; then
      rm -f "$conf_file"
    fi
  fi
done

# Remove all stream configs (they're all generated)
rm -f "$NGINX_STREAM_D"/*.conf

echo "Generating nginx configurations from projects.conf..."

# Process each project
for project in $projects; do
  enabled=$(yq eval ".$project.enabled" "$CONFIG_FILE" 2>/dev/null || echo "true")
  
  if [ "$enabled" != "true" ]; then
    echo "  Skipping disabled project: $project"
    continue
  fi
  
  type=$(yq eval ".$project.type" "$CONFIG_FILE" 2>/dev/null || echo "")
  domain=$(yq eval ".$project.domain" "$CONFIG_FILE" 2>/dev/null || echo "")
  ssl=$(yq eval ".$project.ssl" "$CONFIG_FILE" 2>/dev/null || echo "false")
  
  if [ -z "$domain" ]; then
    echo "  Warning: Project '$project' has no domain, skipping"
    continue
  fi
  
  conf_file="$NGINX_CONF_D/$project.conf"
  
  echo "  Generating config for: $project ($domain)"
  
  # Generate SSL certificate if SSL is enabled (true or proxy mode)
  if [ "$ssl" = "true" ] || [ "$ssl" = "proxy" ]; then
    if ! command -v mkcert >/dev/null 2>&1; then
      echo "    Warning: mkcert not found, SSL certificate not generated"
    else
      if [ ! -f "$CERTS_PATH/$domain.crt" ] || [ ! -f "$CERTS_PATH/$domain.key" ]; then
        echo "    Generating SSL certificate for $domain..."
        mkcert -cert-file "$CERTS_PATH/$domain.crt" -key-file "$CERTS_PATH/$domain.key" "$domain" 2>/dev/null || true
      fi
    fi
  fi
  
  # Start writing config file
  {
    echo "# Generated by generate-nginx-configs.sh"
    echo "# Project: $project"
    echo ""
  } > "$conf_file"
  
  if [ "$type" = "proxy" ]; then
    # Proxy type - proxy to localhost ports
    http_port=$(yq eval ".$project.http.port" "$CONFIG_FILE" 2>/dev/null || echo "")
    http_enabled=$(yq eval ".$project.http.enabled" "$CONFIG_FILE" 2>/dev/null || echo "false")
    https_port=$(yq eval ".$project.https.port" "$CONFIG_FILE" 2>/dev/null || echo "")
    https_enabled=$(yq eval ".$project.https.enabled" "$CONFIG_FILE" 2>/dev/null || echo "false")
    
    # Check if WSS is enabled
    wss_enabled=$(yq eval ".$project.wss.enabled" "$CONFIG_FILE" 2>/dev/null || echo "false")
    wss_port=$(yq eval ".$project.wss.port" "$CONFIG_FILE" 2>/dev/null || echo "")
    
    # Determine if HTTP should redirect to HTTPS
    # Redirect if SSL is enabled (true or proxy mode)
    should_redirect_http=false
    if [ "$https_enabled" = "true" ] && [ -n "$https_port" ] && [ "$https_port" != "null" ]; then
      if [ "$ssl" = "true" ] || [ "$ssl" = "proxy" ]; then
        should_redirect_http=true
      fi
    fi
    
    # HTTP server block
    if [ "$http_enabled" = "true" ] && [ -n "$http_port" ] && [ "$http_port" != "null" ]; then
      if [ "$should_redirect_http" = "true" ]; then
        # HTTP redirects to HTTPS
        cat >> "$conf_file" <<EOF
server {
    listen 80;
    server_name $domain;
    location / {
        return 301 https://$domain\$request_uri;
    }
}

EOF
      else
        # HTTP proxies to backend
        cat >> "$conf_file" <<EOF
server {
    listen 80;
    server_name $domain;
    
    location / {
        proxy_pass http://host.docker.internal:$http_port;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
    }
}

EOF
      fi
    fi
    
    # HTTPS server block
    if [ "$https_enabled" = "true" ] && [ -n "$https_port" ] && [ "$https_port" != "null" ]; then
      # Check if SSL is enabled (true, on) or proxy mode (proxy)
      if [ "$ssl" = "true" ] || [ "$ssl" = "proxy" ]; then
        # Determine if we need WebSocket support
        if [ "$wss_enabled" = "true" ]; then
          # Use WSS port if specified, otherwise use HTTPS port
          backend_port="${wss_port:-$https_port}"
          cat >> "$conf_file" <<EOF
server {
    listen 443 ssl;
    server_name $domain;
    ssl_certificate     /etc/nginx/certs/$domain.crt;
    ssl_certificate_key /etc/nginx/certs/$domain.key;
    
    location / {
        proxy_pass http://host.docker.internal:$backend_port;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_set_header X-Forwarded-Host \$host;
        proxy_set_header X-Forwarded-Port 443;
        proxy_set_header X-Forwarded-Ssl on;
        proxy_read_timeout 86400;
        proxy_send_timeout 86400;
    }
}

EOF
        else
          # Determine backend protocol: proxy mode uses HTTP, true uses HTTPS
          if [ "$ssl" = "proxy" ]; then
            backend_protocol="http"
          else
            backend_protocol="https"
          fi
          cat >> "$conf_file" <<EOF
server {
    listen 443 ssl;
    server_name $domain;
    ssl_certificate     /etc/nginx/certs/$domain.crt;
    ssl_certificate_key /etc/nginx/certs/$domain.key;
    
    location / {
        proxy_pass $backend_protocol://host.docker.internal:$https_port;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_set_header X-Forwarded-Host \$host;
        proxy_set_header X-Forwarded-Port 443;
        proxy_set_header X-Forwarded-Ssl on;
    }
}

EOF
        fi
      else
        cat >> "$conf_file" <<EOF
server {
    listen 443 ssl;
    server_name $domain;
    ssl_certificate     /etc/nginx/certs/$domain.crt;
    ssl_certificate_key /etc/nginx/certs/$domain.key;
    
    location / {
        proxy_pass http://host.docker.internal:$https_port;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_set_header X-Forwarded-Host \$host;
        proxy_set_header X-Forwarded-Port 443;
        proxy_set_header X-Forwarded-Ssl on;
    }
}

EOF
      fi
    fi
    
  elif [ "$type" = "site" ]; then
    # Site type - proxy to Docker containers
    target_container=$(yq eval ".$project.target.container" "$CONFIG_FILE" 2>/dev/null || echo "")
    proxy_type=$(yq eval ".$project.target.proxy_type" "$CONFIG_FILE" 2>/dev/null || echo "80")
    
    if [ -z "$target_container" ]; then
      echo "    Warning: Project '$project' has no target container, skipping"
      rm -f "$conf_file"
      continue
    fi
    
    # HTTP redirect to HTTPS (if SSL enabled - true or proxy mode)
    if [ "$ssl" = "true" ] || [ "$ssl" = "proxy" ]; then
      cat >> "$conf_file" <<EOF
server {
    listen 80;
    server_name $domain;
    location / {
        return 301 https://$domain\$request_uri;
    }
}

EOF
    fi
    
    # HTTPS server block
    if [ "$ssl" = "true" ] || [ "$ssl" = "proxy" ]; then
      if [ "$proxy_type" = "fpm" ]; then
        fpm_container=$(yq eval ".$project.target.fpm.container" "$CONFIG_FILE" 2>/dev/null || echo "$target_container")
        fpm_port=$(yq eval ".$project.target.fpm.port" "$CONFIG_FILE" 2>/dev/null || echo "9000")
        
        cat >> "$conf_file" <<EOF
server {
    listen 443 ssl;
    server_name $domain;
    ssl_certificate     /etc/nginx/certs/$domain.crt;
    ssl_certificate_key /etc/nginx/certs/$domain.key;
    
    # DNS resolver for dynamic resolution
    resolver 127.0.0.11 valid=10s ipv6=off;
    resolver_timeout 5s;
    
    root /usr/share/nginx/html;
    index index.php index.html;
    
    location / {
        try_files \$uri \$uri/ /index.php?\$query_string;
    }
    
    location ~ \.php$ {
        # Use variable to force dynamic DNS resolution
        set \$backend "$fpm_container:$fpm_port";
        include fastcgi_params;
        fastcgi_pass \$backend;
        fastcgi_param SCRIPT_FILENAME \$document_root\$fastcgi_script_name;
        fastcgi_index index.php;
    }
}

EOF
      elif [ "$proxy_type" = "ssl" ] || [ "$proxy_type" = "443" ]; then
        cat >> "$conf_file" <<EOF
server {
    listen 443 ssl;
    server_name $domain;
    ssl_certificate     /etc/nginx/certs/$domain.crt;
    ssl_certificate_key /etc/nginx/certs/$domain.key;
    
    # DNS resolver for dynamic resolution
    resolver 127.0.0.11 valid=10s ipv6=off;
    resolver_timeout 5s;
    
    location / {
        # Use variable to force dynamic DNS resolution
        set \$backend "$target_container";
        proxy_pass https://\$backend:443;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
    }
}

EOF
      else
        # Default: proxy_pass to target:80
        cat >> "$conf_file" <<EOF
server {
    listen 443 ssl;
    server_name $domain;
    ssl_certificate     /etc/nginx/certs/$domain.crt;
    ssl_certificate_key /etc/nginx/certs/$domain.key;
    
    # DNS resolver for dynamic resolution
    resolver 127.0.0.11 valid=10s ipv6=off;
    resolver_timeout 5s;
    
    location / {
        # Use variable to force dynamic DNS resolution
        set \$backend "$target_container";
        proxy_pass http://\$backend:80;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
    }
}

EOF
      fi
    fi
  fi
  
  # Generate MySQL stream config if enabled
  mysql_enabled=$(yq eval ".$project.mysql.enabled" "$CONFIG_FILE" 2>/dev/null || echo "false")
  
  if [ "$mysql_enabled" = "true" ]; then
    mysql_port=$(yq eval ".$project.mysql.port" "$CONFIG_FILE" 2>/dev/null || echo "")
    mysql_target=$(yq eval ".$project.mysql.target" "$CONFIG_FILE" 2>/dev/null || echo "localhost")
    mysql_target_port=$(yq eval ".$project.mysql.target_port" "$CONFIG_FILE" 2>/dev/null || echo "3306")
    
    if [ -n "$mysql_port" ] && [ "$mysql_port" != "null" ]; then
      stream_file="$NGINX_STREAM_D/$project-mysql.conf"
      
      {
        echo "# Generated by generate-nginx-configs.sh"
        echo "# MySQL stream proxy for $project"
        echo ""
        echo "upstream ${project}_mysql {"
        
        if [ "$mysql_target" = "localhost" ]; then
          echo "    server host.docker.internal:$mysql_target_port;"
        else
          echo "    server $mysql_target:$mysql_target_port;"
        fi
        
        echo "}"
        echo ""
        echo "server {"
        echo "    listen $mysql_port;"
        echo "    proxy_pass ${project}_mysql;"
        echo "    proxy_timeout 1s;"
        echo "    proxy_responses 1;"
        echo "    error_log /var/log/nginx/${project}-mysql-error.log;"
        echo "}"
      } > "$stream_file"
      
      echo "    Generated MySQL stream config: $mysql_port -> $mysql_target:$mysql_target_port"
    fi
  fi
done

echo ""
echo "Nginx configurations generated successfully!"

# Reload nginx
if [ -f "$SCRIPT_DIR/reload-nginx.sh" ]; then
  echo "Reloading nginx..."
  sh "$SCRIPT_DIR/reload-nginx.sh"
fi
